# HTTP 웹 기본 지식 8

## 캐시

캐시를 사용하는 상황은 언제일까? 주로 브라우저의 이미지파일을 저장해놓고 해당 홈페이지를 로딩할 때 바로 리소스를 가져오도록 하기 위해서 사용될 것이다. 캐시를 사용해야하는 상황에 대해 사진으로 알아보자.

![](images/2021-11-02-17-38-19.png)

웹 브라우저가 star.jpg라는 이미지를 서버에 요청하면 서버는 star.jpg를 클라이언트에 전송할 것이다. 여기서 HTTP 헤더는 0.1MB, star.jpg는 1.0MB라고 가정해보자. 서버는 웹브라우저에게 총 1.1MB의 데이터를 전송하였고, 클라이언트는 성공적으로 웹페이지에 star.jpg를 출력했다.

![](images/2021-11-02-17-39-21.png)

클라이언트가 웹페이지를 탐색하다가 다시 star.jpg를 요청해야하는 상황이 되었다. 서버는 HTTP 요청 메시지를 읽고 다시 클라이언트에게 star.jpg파일을 전송한다. 1.1MB의 데이터가 다시 전송된다.

뭔가 비효율적이다. 클라이언트에서 한번 받았던 데이터를 서버에서 매 번 전송을 해야하는 것은 자원낭비이다. 클라이언트 측에서 서버로부터 받은 데이터를 가지고 있으면서 서버에서 해당 데이터가 변경되지 않았으면 클라이언트가 가지고 있던 데이터를 다시 재활용하게 만드는 것이 캐시이다.

캐시가 없다면 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다. 인터넷 네트워크 자원은 매우 느리고 비싸기 대문에 브라우저 로딩속도가 느려질 뿐 더러 사용자의 경험도 나빠진다.

<br>

![](images/2021-11-02-17-41-35.png)

이번엔 캐시를 사용할 때 클라이언트가 star.jpg를 서버에 요청하는 상황이다. 서버는 클라이언트에 star.jpg를 넘겨준다.

![](images/2021-11-02-17-42-05.png)

클라이언트는 서버로부터 받은 star.jpg를 브라우저 캐시에 저장한다. 서버에서 정한 캐시 유효시간 데이터를 읽은 다음 그 시간동안 유효한 캐시데이터를 저장소에 저장한다.

이후 브라우저는 star.jpg가 필요한 페이지에서 데이터를 확인하고 싶을 때 캐시 저장소에 있는 star.jpg를 불러와서 페이지에 출력하여 볼 수 있게 된다.

<br>

### 캐시의 특징

- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빨라진다.
- 결과적으로 빠른 사용자 경험을 가질 수 있게 해준다.

그렇다면 캐시의 유효시간이 지났을 경우에는 어떻게 처리될까? 캐시 유효시간이 초과하면 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다. 이 때 다시 네트워크 다운로드가 발생하게 된다.

사실 캐시 유효시간이 초과해서 클라이언트가 서버에 다시 해당 데이터를 요청하면 2가지 상황이 일어난다.

1. 서버에서 기존 데이터를 변경했을 경우 : 서버에서 해당 데이터를 변경했을 경우 클라이언트는 서버 측에서 데이터를 다시 전달받아야한다.

2. 서버에서 기존 데이터를 변경하지 않았을 경우 : 캐시가 만료되었지만 서버에서 해당 데이터를 변경하지 않았을 경우에는 저장했던 캐시데이터를 다시 사용해도 상관이 없다.
   단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다.

2번의 경우에는 **검증 헤더**를 사용하여 클라이언트의 데이터가 서버의 데이터와 일치하는지 여부를 확인이 가능하다.

<br>

## 검증 헤더

검증헤더를 사용했을 경우 클라이언트의 캐시데이터가 어떻게 처리되는지를 알아보자.

![](images/2021-11-02-17-48-43.png)

먼저 클라이언트가 star.jpg를 서버에 요청한다. 서버는 star.jpg를 클라이언트에 전달하면서 star.jpg의 **최종수정일을 클라이언트에 보낸다.** 클라이언트는 받은 데이터를 브라우저 캐시저장소에 저장한다.

![](images/2021-11-02-17-49-40.png)

클라이언트의 캐시데이터 시간이 만료되어 서버에 다시 star.jpg를 요청한다. 요청할 때 HTTP 헤더에 if-modified-since를 보낸다. 클라이언트가 가지고 있는 star.jpg의 최종수정일이 서버의 최종수정일과 다른지를 확인하는 것이다.

최종 수정일이 다르지 않다는 것을 확인한 서버는 HTTP헤더에 304 Not Modified라는 상태코드를 넣어서 보내게 된다. 수정되지 않았으므로 캐시데이터를 그대로 사용하라는 의미가 된다 **이 때, 이미지는 보내지 않고 HTTP 헤더만 보내게 되므로 데이터 용량은 0.1MB가 된다.**

클라이언트는 서버의 응답을 받고 캐시데이터를 갱신하여 캐시저장소에서 불러온 이미지를 다시 사용하여 홈페이지를 랜더링하게 된다.

정리를 하자면 다음과 같다.

- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면
- 304 Not Modified + 헤더 메타정보만 응답데이터에 보낸다.
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타정보를 갱신한다.
- 클라이언트는 캐시에 저장되어있는 데이터를 재활용한다.
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드 한다.
- 실용적인 해결책이라 볼 수 있다.

<br>

## 검증 헤더와 조건부 요청

### 검증 헤더

- 검증 헤더는 캐시 데이터외 서버 데이터가 같은지 검증하는 데이터이다.
- Last-Modified, ETag가 있다.

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since: Last-Modified를 사용한다.
- If-None-Match: ETag를 사용한다.
- 조건이 만족하게되면 200 OK로 응답한다.
- 조건이 만족하지 않으면 304 Not Modified로 응답한다. (실패했다는 것이 아니라 데이터가 수정된 것이 없으니 그대로 사용하라는 뜻이다.)

ETag가 존재하는 이유에 주목해야한다. 위에서 캐시데이터의 최종 수정일을 비교하여 변경된 사항이 없으면 캐시데이터를 그대로 사용하였다. 먼저 Last-Modified, If-Modified-Since의 단점에 대해서 알아보자.

- 1초 미만(0.x초) 단위로 캐시 조정이 불가능하다.
- 날짜 기반의 로직을 사용한다.
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
  - 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우, 이미 데이터가 약간이라도 변경되어 최종수정일이 갱신되어서 다시 데이터를 받아야한다.

위의 단점을 개선하기 위해서 ETag를 사용한다. ETag는 Entity Tag의 줄임말로, 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔 것이다.

> ETag: "v1.0", ETag: "a2jiodwjekjl3"

데이터가 변경되면 ETag의 이름을 바꾸어서 변경한다(Hash를 다시 생성하는 것이다.)

> ETag: "aaaaa" -> ETag: "bbbbb"

캐시데이터를 갱신할 때는 단순하게 ETag만 비교하여 같으면 유지하고, 다르면 다시 받도록 처리한다. 아래 사진은 ETag로 캐시데이터를 갱신하는 것을 그림으로 표현한 것이다.

![](images/2021-11-02-21-39-23.png)

![](images/2021-11-02-21-39-48.png)

### ETag 정리

- 단순히 ETag만 서버에 보내서 같으면 유지하고, 다르면 다시 받는다.
- **캐시 제어 로직을 서버에서 완전히 관리하게 된다.**
- 클라이언트는 단순히 이 값을 서버에 제공한다(클라이언트는 캐시 매커니즘을 모른다.)

<br>

## 캐시 제어 헤더

- Cache-Control: 캐시를 제어
  - Cache-Control: max-age
    - 캐시의 유효시간, **초 단위** 기준이다.
  - Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용하도록 설정
  - Cache-Control: no-store
    - 데이터에 민감한 정보가 있어서 캐시로 저장하면 안되는 데이터(메모리에서 사용 후 최대한 빨리 삭제한다.)
- Pragma : 케시를 제어(Cache-Control 하위호환)

  - Cache-Control과 역할은 같다. 주로 HTTP 1.0에 호환하기 위해서 사용한다.

- Expires : 캐시 만료일을 지정(Cache-Control: max-age 하위호환)
  - 캐시 만료일을 정확한 **날짜로 지정**한다.
  - HTTP 1.0부터 사용할 수 있다.
  - 지금은 더 유연하게 적용이 가능한 Cache-Control: max-age를 권장한다.
  - Cache-Control: max-age와 함께 사용 시 Expires는 무시된다.

<br>

## 검증 헤더와 조건부 요청 헤더

- 검증 헤더(Validator)

  - ETag: "v1.0", ETag: "asid93jkrh2l"
  - Last-Modified: Thu, 04 Jun 2020 07:19:24 GMT

- 조건부 요청 헤더
  - If-Match, If-None-Match: ETag 값 사용
  - If-Modified-Since, If-Unmodified-Since: Last-Modified값 사용

<br>

## 프록시 캐시

![](images/2021-11-02-21-54-35.png)

클라이언트가 미국에 있는 원 서버에 접근하기 까지 0.5초의 시간이 걸린다. 0.5초는 짧은 시간이지만 웹페이지를 이동할 때마다 0.5초를 기다리는 것은 사용자입장에서 좋은 경험이 아니다.

따라서 프록시 캐시 서버를 만들어서 미국에서 먼 사용자들이 프록시 캐시서버를 사용하여 웹페이지와 통신할 수 있도록 설계하면 이를 개선시킬 수 있다. CDN같은 서비스가 이에 해당한다.

유튜브를 예로 들자면, 영상을 맨 처음 보는 유저는 캐시를 다운로드받아야해서 로딩 속도가 느려진다. 하지만 다른사람들은 처음 본 유저 덕분에 캐시가 다운로드되어 영상을 빠른속도로 볼 수 있게 된다.

중간에서 공용으로 사용하는 프록시 캐시서버를 public 캐시라 하고, 웹 브라우저에서 사용하는 캐시를 private 캐시라고 한다.

<br>

### Cache-Control: 캐시 지시어(기타)

- Cache-Control: public - 응답이 public 캐시에 저장되어도 된다는 뜻이다.

- Cache-Control: private - 응답이 해당 사용자만을 위한 것이다. private 캐시에 저장되어야한다.(기본값)

<br>

## 캐시 무효화

### Cache-Control: 확실한 캐시 무효화 응답

캐시가 되어선 안되는 데이터는 캐시가 되지 않도록 설정해주어야 한다.

- Cache-Control: no-cache, no-store, must-revalidate

![](images/2021-11-02-21-58-41.png)

- no-cache: 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용한다.

no-cache를 한다고 가정해보자, 원 서버에 검증하고 사용해야되므로, 프록시서버에서 no-cache를 확인하면 원서버로 캐시데이터를 보낸다.

하지만 원서버가 순간적으로 접속이 끊겨서 원서버에서 검증을 실패했다고 가정해보자, 이럴 경우 **프록시 서버에서는 이전 데이터를 클라이언트 측으로 보낸다.**

에를들어 통장 잔고나 민감한 개인정보의 경우는 이전 데이터를 클라이언트로 보내서는 안된다. 자칫 사용자에게 정보에 대한 혼동을 줄 수 있게된다.

![](images/2021-11-02-22-00-25.png)

- must-revalidate: 캐시 만료 후 최초 조회 시 원 서버에 검증을 해야한다.
  원 서버에 접근 실패 시 반드시 오류가 발생해야한다. - 504(Gateway Timeout)
  must-revalidate는 캐시 유효시간이라면 캐시를 사용한다.

must-revalidate는 캐시 만료 후 최초 조회 시 원 서버에 검증해야하는 것은 no-cache와 같은 공통점을 가진다. 하지만 원 서버에 접근 실패 시 반드시 오류가 발생해야하는 조건을 가지고 있다. 따라서 반드시 원 서버에서 검증 후에 데이터를 사용해야할 경우 must-revalidate를 넣어주어야 한다.

- no-store: 데이터에 민감한 정보가 있으므로 저장하면 안된다(메모리에서 사용 후 최대한 빨리 삭제)

- Pragma: no-cache
  - HTTP 1.0 하위호환
