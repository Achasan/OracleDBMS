## 다양한 의존관계 주입 방법

[의존 관계 주입 방법 4가지]

- 생성자 주입 : 말 그대로 생성자로 주입, 지금까지 진행한 방법. 생성자 호출 시점에 딱 1번만 호출되는 점이 보장됨, 불변/필수의존관계에 사용한다.

생성자는 두 번 호출이 안된다. 강제호출이 안되기 때문에 불변에 해당한다.

> 좋은 개발습관은 제약이 있게 설계하는 것, 모든것에 열려있으면 뭘 수정해야할지 알기 힘듦 예를 들자면 공연 중간에 배우를 바꿀일이 없어야한다 > 공연이 시작하는 순간 배우는 바꿀수 없음 : 불변

필수 : 우리가 구현체 클래스가 작동하기 위해서 필요한 필드변수를 선언했었다. (MemoryMemberRepository, DiscountPolicy 등) 필드 변수를 선언한 이유는 어플리케이션이 실행됐을 때 해당 변수에 값을 저장하고 클래스가 가진 비즈니스 로직을 수행하기 위한 것이다.

따라서 웬만해서는 그 필드변수가 null값을 가지지 않도록 해야한다. 생성자 주입에서 생성자에 값을 넣지 않으면 컴파일 오류가 발생한다. 생성자에 값을 넣어야하도록 개발자가 의도하여 설계한 것이기 때문이다. 개발문서에서 null을 넣어도 된다고 작성하지 않는 이상 생성자에 null을 넣는 것은 허용되지않는다. 구현체의 정상적인 로직이 수행될 수 없기 때문이다. 이것이 필수에 해당한다.

※ 생성자가 딱 하나만 있으면 @Autowired를 생략해도 된다. 2개 이상부터는 작성해야함. 스프링 빈에만 해당된다. (파라미터가 2개 이상이라는 뜻이 아니다. 생성자가 하나여야된다는 뜻(생성자 오버로딩이 아닐 때))

<br>

[수정자 주입]

Setter 메서드를 사용해서 수동으로 의존관계를 주입한다. setXXX() 형태로 되어있는데,

예를들어 MemberRepository 객체 의존관계를 지정할 때는

    public void setMemberRepository(MemberRepository memberRepository) {
        this.MemberRepository = memberRepository;
    }

다음과 같이 Setter메서드를 사용하여 지정하는 것이다. Setter 메서드에 @AutoWired를 사용하면 자동주입이 된다. (없으면 의존관계 주입 안됨)

특징

- 선택, 변경 가능성이 있는 의존 관계에 사용한다.
  의존관계가 필수적인 경우가 아니면 의존관계를 넣어도 되고 안넣어도 상관없다. setter 메서드를 사용하면 선택적으로 구현이 가능하다.
  변경은 중간에 내가 인스턴스를 바꾸고 싶을 경우에 사용한다(그럴일 거의 없음)

※ @Autowired(required = false) : 스프링이 오토와이어를 보더라도 의존관계 주입을 하지 않는다. 또한 주입할 대상이 없을 경우에는 어노테이션이 예외를 출력하는데, 위와 같이 설정하면 주입할 대상이 없어도 동작이 가능하게 할 수 있다.

<br>

[필드 주입]

필드 변수에 바로 @Autowired를 작성하여 의존관계를 주입.
private임에도 불구하고 의존관계 주입이 가능

"field injection is not recommend"
테스트 코드를 작성할 때는 순수한 자바코드로 실행이 되기 때문에 스프링으로 의존관계 주입이 되어서 서버에서 사용이 가능하더라도 테스트에서는 NullPointerException이 발생하게된다.

따라서 테스트를 위해서 생성한 메서드는 setter를 또 따로 만들어주어야되는데, 이러면 수정자 주입을 사용하는게 더 나은 상황이 되어버린다.

결론 : DI프레임워크가 없으면 작동되지않는 방법. 비권장

<br>

[일반 메서드 주입]

한번에 여러 필드를 주입 받을 수 있다. 일반적으로 잘 사용하지 않음, 생성자 주입이나 수정자 주입에서 다 해결 가능한 케이스

<br>

[자동 주입 대상 옵션처리 방법]

1. @Autowired(required = false) : 자동주입할 대상이 없으면 수정자 메서드 자체가 호출이 안된다.

2. @Nullable : 스프링 프레임워크에서 지원, 자동 주입할 대상이 없으면 null이 입력된다.

3. Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.

<br>

위에서 의존관계를 자동주입하는 여러가지 방법들을 살펴보았다. 하지만 김영한님은 생성자 주입을 선택하는 것을 권장하고 있다.

<br>

[생성자 주입을 선택해야하는 이유]

대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 DI는 변하면 안된다. (불변해야한다.) 수정자 주입을 사용할 경우 setter는 public으로 열어두어야된다.(보안)

> 누군가 실수로 변경할 가능성, 변경하면 안되는 메서드를 열어두는 것은 좋은 설계방법이 아니다.

생성자 주입은 생성할 때 딱 한 번만 호출이 된다. 따라서 불변에 성립하는 주입이다.

<br>

누락 :

수정자 주입을 사용하게 되면 순수한 자바코드로 해당 클래스의 메소드만 테스트를 하고 싶을 때 클래스를 실행하기 위해 어떤 구현체가 필요한지 알기 힘들다. 반대로 생성자 주입을 사용했을 떄는 테스트 코드를 작성할 때 생성자에 구현체를 넣어주어야 되므로 어떤 구현체가 필요한지를 바로 파악할 수가 있다.

또한 수정자 주입을 할 때는 가짜객체를 넣어주어서 테스트코드가 작동되게끔 해야되는데 생성자주입에서는 가능하지만 수정자 주입에서는 불가능하다. 따라서 생성자 주입을 사용해야하는 이유 중 하나가 된다. 객체가 누락되는 것이다.

<br>

final 키워드를 지킬 수 있음 :

final은 변하지 않는 값을 선언할 때 사용하는 것이다. final은 초기화 될때 변수에 값이 들어와야한다. 들어오지 않으면 자바에서 컴파일 오류를 발생시킨다. final을 선언하지 않으면 생성자 코드를 잘못 작성했을 때, 테스트 코드를 실행하면 아무런 반응이 안나오고 어디서 오류가 나는지를 한 눈에 알아보기 힘들다. 따라서 final을 사용할 수 있는 생성자 주입을 사용하는 것이 좋다.

(컴파일 오류가 가장 빠른 오류이다 > 가장 빨리 오류를 잡을 수 있어서 자바에서 오류를 출력하도록 유도)

<br>

생성자 주입방식은 프레임워크에 의존하지 않고 순수 자바 언어의 특징을 잘 살리는 방법이다.

기본으로 생성자 주입을 사용하고 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.

항상 생성자 주입을 선택하고, 가끔 옵션이 필요할 때 수정자 주입을 선택하는 것이 좋다. 필드 주입은 비권장한다.
