# 20211019 TIL : Spring

인프런에 정리한 내용은 [여기](https://www.inflearn.com/notes/15427)

## 스프링 탄생 배경?

아무리 기술이 복잡하고 개념이 많더라도 처음에 나오는 핵심 컨셉은 굉장히 단순하게 시작한다. Spring도 처음이는 3만줄의 코드로 시작했지만 현재는 모든 것을 다 알기 힘들 정도의 거대한 생태계를 자랑한다.

왜 Spring이 좋은 기술이되었고 무엇때문에 이렇게까지 많은 프레임워크와 기술들이 발달하게 되었는지를 알아야한다. 이 프레임워크가 발달한 배경과 핵심컨셉을 알아야 맥락을 파악할 수 있게되고 왜 이런 API들을 사용해야하는지에 대해서 알게 되는 것이다. 이 부분이 굉장히 중요하다.

Spring은 객체지향언어가 가진 강력한 특징을 살려내는 프레임워크로, 좋은 객체 지향 어플리케이션을 개발할 수 있도록 도와주는 프레임워크라는 점에서 우리는 객체 지향적인 프로그래밍적 사고를 가져야될 것이다.

<br>

## 좋은 객체 지향 설계의 5가지 원칙(SOLID)

SOLID : 좋은 객체 지향 설계의 5가지 원칙 by 로버트 마틴

1. SRP (Single Responsibility Princible)

- 한 클래스는 하나의 책임을 가져야한다.
- 여기서 책임이라는 단어가 모호한 단어로 보일 수 있는데, 얼마나 책임을 져야하는지가 문맥과 상황에 따라 다르기 때문
- 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 이 원칙을 잘 따른 것

2. OCP (Open/Closed Principle)

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀있어야 한다(?)
- 자동차가 디젤차를 전기차로 바꿔도 운전자는 영향받지 않는다. 공연도 역할과 구현이 나뉘어져 있어 서로 영향받지 않는다. 이것이 OCP이다. 변경을 하지말고 다형성을 적극적으로 활용하여 확장을 하고 변경을 하지 않도록 설계하여야 한다.

하지만 OCP에는 문제점이 있다. 구현 객체를 변경하기 위해서는 클라이언트 코드를 변경해야한다는 점이다. 디젤차를 전기차로 바꾸려면 모듈을 전기차로 바꾸어야하는데, 이 과정에서 코드가 변경된다는 것, 클라이언트의 코드를 바꿔야한다는 것이 원칙을 위반하게 된다는 것이다.

따라서 이 원칙을 깨지 않고 모듈을 바꾸기 위해서는 객체와의 연관관계를 맺어주는 별도의 조립, 설정자가 필요해졌는데, 이 역할을 Spring이 수행하게된다.

3. LSP 리스코프 치환 원칙 (Liskov Substitution Principle)

- 인터페이스에는 기능을 설계할 때 기능이 어떤식으로 사용되어져야하는지에 대한 규약을 세우게 된다. 예를 들어, 엑셀을 밟으면 차가 앞으로 가게 된다. 하지만 뒤로 가게 설정하여도 컴파일하는데 문제가 없고, 코드 자체에는 문제가 없다.

하지만 우리가 생각하는 엑셀은 차가 앞으로 나가게 하기위한 장치이지, 뒤로가도록 설계하지는 않는다. LSP는 인터페이스가 기능에 대한 규약에 대해서 보장이 되어야한다는 원칙을 말한다.

4. ISP (Interface Segregation Principle)

- 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 한 인터페이스에서 담당하는 기능의 범위가 커지면 일부분을 바꾸기 위해서 여러가지 작업을 해야해서 효율성이 떨어진다.
- 따라서 각 기능의 범위별로 인터페이스를 분리한다면 인터페이스가 명확해지고, 대체 가능성도 높아질 뿐더러, 서로의 인터페이스에 영향을 주지 않게 된다.

5. DIP (Dependency Inversion Principle)

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다. 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
- 구현 클래스에 의존하지말고 인터페이스에 의존하라는 뜻이다.
- 운전자가 자동차가 가지고 있는 역할, 기능에 대해서 알아야지 K3 기종을 엄청나게 잘 알고있다면 다른 차종을 운전하기가 쉽지 않을 것이다. 공연도 마찬가지이다. 배우가 공연 내용과 대본에 대해서 잘 알고 있어야지 상대 배우에 대해서만 알고 있다면 정상적으로 공연이 진행이 될까?
- 클라이언트가 인터페이스에 의존해야 유연하게 변경이 가능해진다.
- 하지만 우리가 이전 강의에서 구현했던 MemberService 클래스를 보자. MemberRepository 추상 객체와 MemoryMemberRepository 구현 객체 두 가지 모두 의존하고 있다. 여기서 MemberMemberRepository를 JdbcMemberRepository 구현 객체로 바꾼다면? 추상화보다 구체화에 의존하게 되어 DIP를 위반하게 된다.

위의 다섯 가지 원칙을 통해 총 정리를 하자면,

객체지향의 핵심은 다형성이지만, 다형성 만으로는 쉽게 부품을 갈아 끼우듯 개발하기가 어렵다. 이 말은 OCP와 DIP 원칙을 준수하기가 어렵다는 뜻이다. 다형성 만으로는 구현 객체를 변경 시 클라이언트 코드도 함께 변경되고, 막을 수 없다.

따라서 이를 준수할 수 있을만한 무언가가 필요하다. 이것이 Spring framework의 등장이다.
